# Copyright (c) Torrox GmbH & Co KG. All rights reserved.
# Please note that the content of this file is confidential or protected by law.
# Any unauthorised copying or unauthorised distribution of the information contained herein is prohibited.

require 'pathname'
require 'rake/clean'
require 'yaml'

SOURCE_FOLDER = File.expand_path 'source'
INCLUDE_FOLDER = SOURCE_FOLDER 
SOURCE_FOLDER_PATHNAME = Pathname.new SOURCE_FOLDER
OUTPUT_FOLDER = File.expand_path 'obj'
EXE_FOLDER = File.expand_path 'bin'
LIBRARY_FOLDER = File.expand_path 'lib'
DOCUMENTATION_FOLDER = File.expand_path 'documentation'

OBJECT_FILE_EXT = 'o'
DEPENDS_FILE_EXT = 'd'
SHARED_LIBRARY_FILE_EXT = 'bundle'

INCLUDE_PATH = ['.', INCLUDE_FOLDER]

FLAVORS = %w{debug release coverage}

COMPILER_FLAGS = "-Wall -pedantic -Wno-parentheses -Wno-sign-compare -c -pipe -I#{INCLUDE_FOLDER}"
COMPILER_FLAGS_BY_FLAVORS = {
	'debug' => '-ggdb -O0',
	'release' => '-O3 -DNDEBUG',
	'coverage' => '-ggdb -O0 -fno-inline -fprofile-arcs -ftest-coverage',
}

LINK_FLAGS = "-ggdb"
LINK_FLAGS_BY_FLAVORS = {
	'debug' => '',
	'release' => '',
	'coverage' => '-fprofile-arcs -ftest-coverage -lgcov',
}

SHARED_LINK_FLAGS = "-shared -flat_namespace #{LINK_FLAGS}"
SHARED_LINK_FLAGS_BY_FLAVORS = LINK_FLAGS_BY_FLAVORS

RUBY_EXTENSION_LINK_FLAGS = '-static'

BOOST_LIBRARY_POST_FIX_BY_FLAVOR = {
	'debug' => '-mt',
	'release' => '-mt-d',
	'coverage' => '-mt'
}

GCOV_PATTERN = ['*.gcda', '*.gcov', '*.gcno']

GCOV_PATTERN.each { |p| CLEAN.include p }

DEVICE_NULL = '/dev/null'

executables = []
ALL_TEST_NAMES = []
SHARED_LIBARARIES = []

def library_name_from_path path
	Pathname.new(path).basename.to_s
end

def library_file_name lib, flavor
	File.expand_path(File.join(LIBRARY_FOLDER, flavor, 'lib' + lib)) + '.a'
end

def shared_library_file_name lib, flavor
    File.expand_path(File.join(LIBRARY_FOLDER, flavor, lib)) + '.' + SHARED_LIBRARY_FILE_EXT
end

def external_library_file_name lib, flavor
    lib.start_with?('boost') ? 
        "#{lib}#{BOOST_LIBRARY_POST_FIX_BY_FLAVOR[flavor]}" : lib
end

def exe_file_name exe, flavor
	File.expand_path(File.join(EXE_FOLDER, flavor, exe)) + '.exe'
end

# converts /Users/todi/sioux/source/tools/time.cpp, 'debug', 'o' to /Users/todi/sioux/bin/debug/tools/time.o
def object_file_name_from_source source_file_name, flavor, extension
	file       = File.basename(source_file_name, '.cpp')
	source_dir = Pathname.new(File.dirname(File.absolute_path(source_file_name)))
	rel_dir    = source_dir.relative_path_from(SOURCE_FOLDER_PATHNAME)

	File.join(OUTPUT_FOLDER, flavor, rel_dir, file) + '.' + extension
end

def check_flavor flavor
	raise "flavor #{flavor} not configured" unless FLAVORS.include?(flavor)
end

def expand_include_file_name file_name, path_list, current_path
	path_list.each do |path|
		result = File.join(File.realpath(path, current_path), file_name)
		
		return result if File.exists?(result)
	end

	throw "unable to determine dependencies for inlude \"#{file_name}\"; current_path: #{current_path}"
end

INCLUDE_LINE_PATTERN = /^#[ \t]*include[ \t]*"(.+)"/
SCAN_FILE_CACHE = {}

def scan_file_for_includes source_file, current_path
	dependent_include_files = {}

	cache_key = [current_path, source_file]
	cache = SCAN_FILE_CACHE.fetch(cache_key, nil)
	return cache if cache
	
	rake_output_message("scanning #{source_file}\n")

	File.foreach(source_file) do |line|
		if INCLUDE_LINE_PATTERN.match(line) then
			dependent_include_files[expand_include_file_name($1, INCLUDE_PATH, current_path)] = 1
		end
	end
	
	SCAN_FILE_CACHE[cache_key] = dependent_include_files 
	dependent_include_files
end

def build_dependencies source_file, dependency_file, flavor	
	already_scanned = {}
	to_be_scanned   = {source_file => 1}

	while !to_be_scanned.empty?
		file_name = to_be_scanned.first[0]
		to_be_scanned.delete file_name
		
		unless already_scanned.has_key? file_name then
			already_scanned[file_name] = 1

			to_be_scanned.merge! scan_file_for_includes(file_name, File.split(source_file)[0] )
		end			
	end
	
	File.open(dependency_file, 'w') do |output|
		YAML.dump(already_scanned.keys, output)
	end
end

def build_object source_file, object_file, flavor, dependency_file
	sh "g++ #{source_file} -o #{object_file} #{COMPILER_FLAGS} #{COMPILER_FLAGS_BY_FLAVORS[flavor]}"
end

def read_dependencies dependency_file
	begin
		[*YAML.load_file(dependency_file)]
	rescue
		[]
	end
end

def build_library library_file, object_files, flavor
	File.delete(library_file) if File.exist?(library_file)
	sh "ar -q #{library_file} #{object_files.join(' ')}"
end

# OSX initialize objects in the revers order as they appear on the linker command, so libaries are listed first
# object files are listed second
def build_ruby_extension shared_lib, objects, libraries, external_libraries, flavor
    File.delete( shared_lib ) if File.exist?(shared_lib)
    sh "g++ -o #{shared_lib} #{SHARED_LINK_FLAGS} #{SHARED_LINK_FLAGS_BY_FLAVORS[flavor]} " + 
       "-L#{File.join(LIBRARY_FOLDER, flavor)} " + 
       "#{external_libraries.reverse.collect{ | lib | "-l#{lib}" }.join(' ')} " +
       "#{libraries.collect{|l| '-l' +l }.join(' ')} " +
       "#{objects.join(' ')} "
end

# OSX initialize objects in the revers order as they appear on the linker command, so libaries are listed first
# object files are listed second
def build_executable executable, objects, libraries, external_libraries, flavor
	File.delete(executable) if File.exist?(executable)
	sh "g++ -o #{executable} #{LINK_FLAGS} #{LINK_FLAGS_BY_FLAVORS[flavor]} " + 
	   "-L#{File.join(LIBRARY_FOLDER, flavor)} " +
       "#{external_libraries.reverse.collect{ | lib | "-l#{lib}" }.join(' ')} " +
	   "#{libraries.reverse.collect{|l| '-l' +l }.join(' ')} " +
	   "#{objects.join(' ')}"
end

# List of libraries in the source folder
libraries  = FileList[File.join(SOURCE_FOLDER, '*')].reject do |file|
	!File.directory?(file) 
end.collect do |lib_path|
	library_name_from_path lib_path
end

FLAVORS.each do |flavor|
	directory File.join(LIBRARY_FOLDER, flavor)

	libraries.each do |lib| 
		CLEAN.include File.join(OUTPUT_FOLDER, flavor, lib, '*.' + OBJECT_FILE_EXT)
		CLEAN.include File.join(OUTPUT_FOLDER, flavor, lib, '*.' + DEPENDS_FILE_EXT)

		GCOV_PATTERN.each { |p| CLEAN.include File.join(OUTPUT_FOLDER, flavor, lib, p)  }		
	end
	
	CLOBBER.include File.join(LIBRARY_FOLDER, flavor, '*');
end

def create_object_to_source_dependencies source_files, flavor
	[source_files].flatten.collect do |source_file|
		object_file  = object_file_name_from_source source_file, flavor, OBJECT_FILE_EXT
		depends_file = object_file_name_from_source source_file, flavor, DEPENDS_FILE_EXT
		object_dir   = File.dirname object_file 

		directory object_dir 
		
		depends = [source_file] + read_dependencies(depends_file) + [object_dir]

		file object_file => depends + [depends_file] do
			build_object(source_file, object_file, flavor, depends_file)
		end

		file depends_file => depends do 
			build_dependencies(source_file, depends_file, flavor)
		end
		
		object_file
	end
end

# create libraries task 
library_tasks = libraries.collect do |library_name|
	libs_by_name_and_flavor = {}
	source_files = FileList[File.join(SOURCE_FOLDER, library_name, '*.cpp')].exclude(/.*test\.cpp/)

	FLAVORS.each do |flavor|
		object_files = create_object_to_source_dependencies source_files, flavor 
		lib_file     = library_file_name(library_name, flavor)
		lib_dir      = File.dirname lib_file 

		directory lib_dir
		file lib_file => lib_dir 

		libs_by_name_and_flavor[[library_name, flavor]] = file lib_file  => object_files do |lib|
			build_library lib.name, object_files, flavor unless object_files.empty? 
		end
	end

	task library_name.to_sym, [:flavor] do |t, args|
		args.with_defaults(:flavor => 'debug')
		check_flavor args.flavor
		
		libs_by_name_and_flavor[[library_name, args.flavor]].invoke
	end
end

def run_test test_name, flavor, single_test
    sh exe_file_name( test_name, flavor ), single_test == 'all' ? '' : "--run_test=#{single_test}"
end

# builds tasks for the given test_name.
def test test_name, *dependencies
    ALL_TEST_NAMES << test_name
	params = {:libraries => [], :extern_libs => [], :sources => [] }
	dependencies.each {|p| params.merge! p }
	sources    = params.delete(:sources)
	libraries  = params.delete(:libraries)
	external_libs = params.delete(:extern_libs)
	
	raise "unrecongnized parameters to 'test': #{params}" unless params.empty?

	tests_by_flavor = {}

	FLAVORS.each do |flavor|
		exe_name        = exe_file_name test_name, flavor
		exe_dir         = File.dirname exe_name
		
		object_files       = create_object_to_source_dependencies sources, flavor
		libraries_files    = libraries.collect {|l| library_file_name l, flavor }
		external_lib_files = external_libs.collect {|e| external_library_file_name e, flavor }

		directory exe_dir
		file exe_name => exe_dir 

		tests_by_flavor[flavor] = file exe_name => object_files + libraries_files do |exe|
			build_executable exe_name, object_files, libraries, external_lib_files, flavor
		end 
	end
	
	task test_name.to_sym, [ :flavor, :single_test ] do |t, args|
		args.with_defaults(:flavor => 'debug', :single_test => 'all' )
		check_flavor args.flavor

		tests_by_flavor[args.flavor].invoke
		run_test( test_name, args.flavor, args.single_test )
	end
end

def test_util test_name, *dependencies
    test test_name, *dependencies
end

def component_test test_name, *dependencies
    ALL_TEST_NAMES << test_name
    
    params = { :sources => [], :dependencies => [] }
    dependencies.each {|p| params.merge! p }
    sources         = params.delete( :sources )
    dependencies    = params.delete( :dependencies )
    
    raise "unrecongnized parameters to 'component_test': #{params}" unless params.empty?

    task test_name.to_sym, [ :argument ] => dependencies do | t, args |
        test_name = args[ :argument ]

        sources.each do | source |
            require source
           
            runargs = test_name.nil? ? [] : [ '-n' , "#{test_name}" ]
            MiniTest::Unit.new.run runargs
        end 
    end
end

# build tasks for a ruby extension
def ruby_extension lib_name, *dependencies
    SHARED_LIBARARIES << lib_name 

    params = { :libraries => [], :extern_libs => [], :sources => [] }
    dependencies.each { | p | params.merge! p }
    sources       = params.delete( :sources )
    libraries     = params.delete( :libraries )
    external_libs = params.delete( :extern_libs )

    raise "unrecongnized parameters to 'shared_library': #{params}" unless params.empty?
    
    FLAVORS.each do | flavor |
        lib_file    = shared_library_file_name lib_name, flavor
        lib_dir     = File.dirname lib_file
        
        object_files       = create_object_to_source_dependencies sources, flavor
        libraries_files    = libraries.collect {|l| library_file_name l, flavor }
        external_lib_files = external_libs.collect {|e| external_library_file_name e, flavor }

        directory lib_dir
        file lib_file => lib_dir


        file lib_file => object_files + libraries_files do | args |
            build_ruby_extension lib_file, object_files, libraries, external_lib_files, flavor
        end 
    end     

    task lib_name.to_sym, [ :flavor ] do |t, args|
        args.with_defaults( :flavor => 'debug' )
        check_flavor args.flavor
    
        Rake::Task[ shared_library_file_name lib_name, args.flavor ].invoke
    end
end
 
# include sub rake files (this will populate ALL_TEST_NAMES)
libraries.each do |library_name|
    rakefile = File.join(SOURCE_FOLDER, library_name, 'rakefile')
    if File.exist? rakefile then
        load rakefile
    end  
end

desc 'build all executables shiped with a sioux server'
task :exes => executables

desc 'build all libraries used to build a sioux server'
task :libs, [:flavor] do |t, args|
	args.with_defaults(:flavor => 'debug')
	check_flavor args.flavor

	library_tasks.each { |t| t.invoke(args.flavor) }
end

desc 'run all tests'
task :tests, [:flavor] => ALL_TEST_NAMES

desc 'lists the available tests'
task :list_tests do
    puts "list of all available tests:\n\n"
	puts ALL_TEST_NAMES.collect{|t| "\t#{t}" }.join("\n")
	
	puts <<EOD

All tests have two parameters. The first parameter is the build flavor, the second parameter is the test case to be run.
The default for the flavor is 'debug'. The default for the test case is 'all'. Example:

\trake json_test[debug,json_string_test]

builds the json_test and executes just the json_string_test test case out of the json_test.
EOD
end

desc 'build html documentation'
task :docu do
	sh "doxygen #{ File.expand_path( File.join( SOURCE_FOLDER, 'doxybuild' ) ) } 1> #{ DEVICE_NULL }"
end

desc 'lists all flavors and there meaning'
task :list_flavors do
	print <<STOP
    'debug'     With asserts anabled, without optimization
                and with debug symbols.
    'release'   With full optimization enabled, without debug
                symbols, without asserts.
    'coverage'  Like 'debug', but with instrumentation for
                coverage analysis.
STOP
end

task :default => [:exes, :libs] 

