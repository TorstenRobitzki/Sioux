// Generated by CoffeeScript 1.6.3
(function() {
  var Impl, Node, create_ajax_transport, global, impl;

  global = Function('return this')();

  global.PubSub = global.PubSub || {};

  PubSub.NodeList = (function() {
    var check_node_name, compare_keys, compare_names, find_node, keys_from_name, name_from_keys;

    function NodeList() {
      this.list = [];
    }

    find_node = function(keys, found, not_found) {
      var comp, high, low, mid, val;
      low = 0;
      high = this.list.length - 1;
      while (low <= high) {
        mid = (low + high) >> 1;
        val = this.list[mid];
        comp = compare_keys(keys, val.k);
        if (comp === 0) {
          return found.call(this, val, mid);
        }
        if (comp < 0) {
          low = mid + 1;
        } else {
          high = mid - 1;
        }
      }
      return not_found.call(this, this.list, low);
    };

    NodeList.prototype.get = function(name) {
      var keys;
      keys = keys_from_name(name);
      return find_node.call(this, keys, function(node) {
        return node.n;
      }, function() {
        return null;
      });
    };

    check_node_name = function(name) {
      var empty, key, value;
      if (typeof name !== 'object') {
        throw new Error('node name must be an object');
      }
      empty = true;
      for (key in name) {
        value = name[key];
        empty = false;
        if (typeof value !== 'string') {
          throw new Error('node name must contain only strings');
        }
      }
      if (empty) {
        throw new Error('node name must not be empty');
      }
    };

    compare_names = function(a, b) {
      if (a < b) {
        return -1;
      } else {
        if (b < a) {
          return 1;
        } else {
          return 0;
        }
      }
    };

    keys_from_name = function(name) {
      var key, key_values, value;
      key_values = ((function() {
        var _results;
        _results = [];
        for (key in name) {
          value = name[key];
          _results.push([key, value]);
        }
        return _results;
      })()).sort(function(a, b) {
        return compare_names(a[0], b[0]);
      });
      return key_values;
    };

    name_from_keys = function(keys) {
      var k, key, result, v, _i, _len;
      result = {};
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        key = keys[_i];
        k = key[0], v = key[1];
        result[k] = v;
      }
      return result;
    };

    compare_keys = function(k1, k2) {
      var i, j, key_compare, _i, _j, _ref;
      if (k1.length !== k2.length) {
        return k1.length - k2.length;
      }
      for (i = _i = 0, _ref = k1.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        for (j = _j = 0; _j <= 1; j = ++_j) {
          key_compare = compare_names(k1[i][j], k2[i][j]);
          if (key_compare !== 0) {
            return key_compare;
          }
        }
      }
      return 0;
    };

    NodeList.prototype.insert = function(name, node) {
      var keys;
      check_node_name.call(this, name);
      keys = keys_from_name.call(this, name);
      return find_node.call(this, keys, function(n) {
        return n.n = node;
      }, function(list, index) {
        return list.splice(index, 0, {
          k: keys,
          n: node
        });
      });
    };

    NodeList.prototype.remove = function(name) {
      var keys;
      keys = keys_from_name.call(this, name);
      return find_node.call(this, keys, function(n, index) {
        this.list.splice(index, 1);
        return true;
      }, function() {
        return null;
      });
    };

    NodeList.prototype.each = function(cb) {
      var ele, _i, _len, _ref, _results;
      _ref = this.list;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ele = _ref[_i];
        _results.push(cb(name_from_keys(ele.k), ele.n));
      }
      return _results;
    };

    return NodeList;

  })();

  global = Function('return this')();

  global.PubSub = global.PubSub || {};

  create_ajax_transport = function(url) {
    if (url == null) {
      url = '/pubsub';
    }
    return function(obj, cb, message_url) {
      if (message_url == null) {
        message_url = url;
      }
      return $.ajax({
        url: message_url,
        type: 'POST',
        contentType: 'application/json;charset=UTF-8',
        data: JSON.stringify(obj)
      }).success(function(data, textStatus, jqXHR) {
        return cb(false, data);
      }).error(function(jqXHR, textStatus) {
        return cb(true);
      });
    };
  };

  Node = (function() {
    function Node(cb) {
      this.cb = cb;
    }

    Node.prototype.update = function(key, data) {
      return this.cb(key, data);
    };

    Node.prototype.error = function(key, error) {
      return this.cb(key, null, error);
    };

    return Node;

  })();

  Impl = (function() {
    var disconnect, handle_response, handle_update, issue_request, receive_call_back, try_reconnect;

    function Impl(transport) {
      this.transport = transport != null ? transport : create_ajax_transport();
      this.subjects = new PubSub.NodeList;
      this.pending_subscriptions = [];
      this.pending_unsubscriptions = [];
      this.session_id = null;
      this.reconnecting = false;
      this.current_transports = 0;
    }

    Impl.prototype.subscribe = function(node_name, callback) {
      this.subjects.insert(node_name, new Node(callback));
      this.pending_subscriptions.push(node_name);
      if (!this.reconnecting && (this.session_id || this.current_transports === 0)) {
        return issue_request.call(this);
      }
    };

    Impl.prototype.unsubscribe = function(node_name) {
      if (!this.subjects.remove(node_name)) {
        throw 'not subscribed';
      }
      if (this.session_id && !this.reconnecting) {
        this.pending_unsubscriptions.push(node_name);
        return issue_request.call(this);
      }
    };

    Impl.prototype.publish = function(message, callback) {
      var cb;
      cb = function(error, response) {
        if (callback) {
          if (error) {
            return callback(true);
          } else {
            return callback(false, response[0]);
          }
        }
      };
      return this.transport([message], cb, '/publish');
    };

    issue_request = function() {
      var cmds, payload, pending, _i, _len, _ref,
        _this = this;
      cmds = (function() {
        var _i, _len, _ref, _results;
        _ref = this.pending_subscriptions;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          pending = _ref[_i];
          _results.push({
            subscribe: pending
          });
        }
        return _results;
      }).call(this);
      _ref = this.pending_unsubscriptions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pending = _ref[_i];
        cmds.push({
          unsubscribe: pending
        });
      }
      this.pending_subscriptions = [];
      this.pending_unsubscriptions = [];
      payload = this.session_id ? cmds.length ? {
        id: this.session_id,
        cmd: cmds
      } : {
        id: this.session_id
      } : {
        cmd: cmds
      };
      this.current_transports++;
      return this.transport(payload, function(error, response) {
        return receive_call_back.call(_this, error, response);
      });
    };

    handle_response = function(resp) {
      var msg, node;
      if (resp.subscribe != null) {
        msg = resp.subscribe;
        node = this.subjects.get(msg);
        node.error(msg, resp.error);
        return this.subjects.remove(msg);
      }
    };

    handle_update = function(update) {
      var node;
      node = this.subjects.get(update.key);
      if (node) {
        return node.update(update.key, update.data);
      }
    };

    receive_call_back = function(error, response) {
      var resp, update, _i, _j, _len, _len1, _ref, _ref1;
      this.current_transports--;
      if (error) {
        return disconnect.call(this, true);
      } else {
        if (this.session_id && this.session_id !== response.id) {
          return disconnect.call(this, false, response.id);
        } else {
          this.session_id = response.id;
          if (response.resp != null) {
            _ref = response.resp;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              resp = _ref[_i];
              handle_response.call(this, resp);
            }
          }
          if (response.update != null) {
            _ref1 = response.update;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              update = _ref1[_j];
              handle_update.call(this, update);
            }
          }
          if (this.current_transports === 0 && !this.reconnecting) {
            return issue_request.call(this);
          }
        }
      }
    };

    disconnect = function(wait_before_reconnect, new_session) {
      var _this = this;
      if (new_session == null) {
        new_session = null;
      }
      this.session_id = new_session;
      this.reconnecting = true;
      if (this.current_transports === 0) {
        if (wait_before_reconnect) {
          return setTimeout(function() {
            return try_reconnect.call(_this);
          }, 30000);
        } else {
          return try_reconnect.call(this);
        }
      }
    };

    try_reconnect = function() {
      var _this = this;
      this.reconnecting = false;
      this.pending_unsubscriptions = [];
      this.pending_subscriptions = [];
      this.subjects.each(function(name) {
        return _this.pending_subscriptions.push(name);
      });
      return issue_request.call(this);
    };

    return Impl;

  })();

  impl = null;

  PubSub.reset = function() {
    return impl = new Impl;
  };

  PubSub.subscribe = function(node_name, callback) {
    if (impl == null) {
      impl = new Impl;
    }
    if (arguments.length !== 2) {
      throw 'wrong number of arguments to PubSub.subscribe';
    }
    return impl.subscribe(node_name, callback);
  };

  PubSub.unsubscribe = function(node_name) {
    if (arguments.length !== 1) {
      throw 'wrong number of arguments to PubSub.unsubscribe';
    }
    return impl.unsubscribe(node_name);
  };

  PubSub.publish = function(message, callback) {
    if (impl == null) {
      impl = new Impl;
    }
    if (arguments.length !== 2 && arguments.length !== 1) {
      throw 'wrong number of arguments to PubSub.publish';
    }
    return impl.publish(message, callback);
  };

  PubSub.configure_transport = function(new_transport) {
    return impl = new Impl(new_transport != null ? new_transport : create_ajax_transport());
  };

}).call(this);
